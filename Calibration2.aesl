<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="0" name="OFF"/>
<constant value="1" name="ON"/>
<constant value="1" name="ALIGNREAR"/>
<constant value="2" name="GOFORWARD"/>
<constant value="3" name="TAKETEMP"/>
<constant value="4" name="ALIGNFRONT"/>
<constant value="5" name="ROTATE"/>
<constant value="6" name="PAUSE"/>
<constant value="7" name="WAIT"/>
<constant value="8" name="ALIGNFORSTART"/>
<constant value="9" name="GOTOEND"/>
<constant value="10" name="TURNAROUND"/>
<constant value="3" name="LEDBUTTONMAXINDEX"/>
<constant value="7" name="LEDCIRCLEMAXINDEX"/>
<constant value="3" name="LEDLOW"/>
<constant value="16" name="LEDHIGH"/>
<constant value="100" name="SPEEDFORWARD"/>
<constant value="0" name="SPEEDCORRECTION"/>
<constant value="60" name="SPEEDROTATE"/>
<constant value="50" name="SPEEDALIGN"/>
<constant value="5" name="TIMERFAST"/>
<constant value="500" name="TIMEWAIT"/>
<constant value="2000" name="TIMETAKETEMP"/>
<constant value="3500" name="PROXREAR"/>
<constant value="3600" name="PROXFRONT"/>
<constant value="30" name="PROXTOLERANCE"/>
<constant value="675" name="COUNTERMAXGOFORWARD"/>
<constant value="3" name="COUNTERMAXTAKETEMP"/>
<constant value="500" name="COUNTERMINROTATE"/>
<constant value="3" name="CALIBRATIONMAXINDEX"/>
<constant value="1" name="TRUE"/>
<constant value="0" name="FALSE"/>
<constant value="9" name="TEMPMAXINDEX"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II">#Goal: Explore square of 1m by 1m, outlined with walls and get temperature value every 10 cm. Store those values in SD card.
#Name: Christopher Browne
#Place: ETML, Lausanne

var ledsCircleArray[LEDCIRCLEMAXINDEX + 1]
var ledsButtonArray[LEDBUTTONMAXINDEX + 1]
var calibrationArray[CALIBRATIONMAXINDEX + 1]
var i
var state
var previousState
var nextState
var ledState
var counterTicks #counts every timer tick while robot is going forward
var counterTakeTemp #counts how many times robot has been in TAKETEMP state
var counterTrip #counts how many trips the rotot has traveled
var counterRotate
var counterMaxRotate
var counterMaxRotateCW
var counterMaxRotateCCW
var counterMaxGoForward
var prox1
var prox2
var proxFactor
var temp
var calibrating
var counterCalibration

sub resetLedArray
	for i in 0:LEDCIRCLEMAXINDEX do
		ledsCircleArray[i] = 0
	end
	for i in 0:LEDBUTTONMAXINDEX do
		ledsButtonArray[i] = 0
	end

sub initialize
	callsub resetLedArray
	for i in 0:CALIBRATIONMAXINDEX do
		calibrationArray[i] = 0
	end
	timer.period[0] = TIMERFAST
	state = OFF
	previousState = OFF
	nextState = OFF
	ledState = OFF
	counterTicks = 0
	counterTakeTemp = 0
	counterTrip = 0
	counterRotate = 0
	counterMaxRotate = 0
	counterMaxRotateCW = 0
	counterMaxRotateCCW = 0
	counterMaxGoForward = 0
	prox1 = 0
	prox2 = 0
	proxFactor = 0
	temp = 0
	calibrating = TRUE
	counterCalibration = 0
	
sub goForward
	ledsCircleArray = [LEDHIGH,LEDLOW,0,0,0,0,0,LEDLOW]
	
	#SPEEDCORRECTION can be modified if robot doesn't go in a straight line
	motor.left.target = SPEEDFORWARD + SPEEDCORRECTION
	motor.right.target = SPEEDFORWARD
	
sub stop
	ledsCircleArray = [0,LEDLOW,0,LEDLOW,0,LEDLOW,0,LEDLOW]
	motor.left.target = 0
	motor.right.target = 0
	
#rotateCW means "rotate ClockWise"
sub rotateCW
	ledsCircleArray = [0,LEDLOW,LEDHIGH,LEDLOW,0,0,0,0]
	motor.left.target = SPEEDROTATE
	motor.right.target = -SPEEDROTATE
	
#rotateCCW means "rotate CounterClockWise"
sub rotateCCW
	ledsCircleArray = [0,0,0,0,0,LEDLOW,LEDHIGH,LEDLOW]
	motor.left.target = -SPEEDROTATE
	motor.right.target = SPEEDROTATE
	
sub setProxRear
	prox1 = 5
	prox2 = 6
	proxFactor = 1

sub setProxFront
	prox1 = 1
	prox2 = 3
	proxFactor = -1
	
sub align
	#when rear-left is too close
	if prox.horizontal[prox1] > (PROXREAR + PROXTOLERANCE) then
		motor.left.target = SPEEDALIGN * proxFactor
	end
	#when rear-left is too far
	if prox.horizontal[prox1] &lt; (PROXREAR - PROXTOLERANCE) then
		motor.left.target = -SPEEDALIGN * proxFactor
	end
	#when rear-right is too close
	if prox.horizontal[prox2] > (PROXREAR + PROXTOLERANCE) then
		motor.right.target = SPEEDALIGN * proxFactor
	end
	#when rear-right is too far
	if prox.horizontal[prox2] &lt; (PROXREAR - PROXTOLERANCE) then
		motor.right.target = -SPEEDALIGN * proxFactor
	end
	#stop left motor when distance is correct
	if prox.horizontal[prox1] &lt; (PROXREAR + PROXTOLERANCE) and prox.horizontal[prox1] > (PROXREAR - PROXTOLERANCE) then
		motor.left.target = 0
	end
	#stop right motor when distance is correct
	if prox.horizontal[prox2] &lt; (PROXREAR + PROXTOLERANCE) and prox.horizontal[prox2] > (PROXREAR - PROXTOLERANCE) then
		motor.right.target = 0
	end
	
##################################################
	
onevent buttons

	#"when" is used instead of "if" in the next section, so buttons don't get pushed many times when finger is left down.

	when button.center == 1 do
		ledsButtonArray = [LEDHIGH,LEDHIGH,LEDHIGH,LEDHIGH]
		callsub initialize
	end
	
	when button.forward == 1 do
		ledsButtonArray = [LEDHIGH,LEDLOW,LEDLOW,LEDLOW]
		
		if state == OFF then
			state = ALIGNREAR
		elseif state != PAUSE then
			previousState = state
			state = PAUSE
		else
			state = previousState
		end
	end
	
	when button.backward == 1 do
		ledsButtonArray = [LEDLOW,LEDLOW,LEDHIGH,LEDLOW]
		if state != OFF then
			callsub stop
		else
			state = ROTATE	
		end
		
	end
	
	when button.right == 1 do
		ledsButtonArray = [LEDLOW,LEDHIGH,LEDLOW,LEDLOW]
		
		#switch LED state
		if ledState == OFF then
			ledState = ON
		else
			ledState = OFF
		end
	end
	
	when button.left == 1 do
		ledsButtonArray = [LEDLOW,LEDLOW,LEDLOW,LEDHIGH]
	end
	
	when button.center == 0 and button.forward == 0 and button.backward == 0 and button.right == 0 and button.left == 0 do
		ledsButtonArray = [LEDLOW,LEDLOW,LEDLOW,LEDLOW]
	end
	
	if ledState == OFF then
		callsub resetLedArray
	end
	
	#the following is called every time the state of a button is changed
	call leds.buttons(ledsButtonArray[0],ledsButtonArray[1],ledsButtonArray[2],ledsButtonArray[3])
	call leds.circle(ledsCircleArray[0],ledsCircleArray[1],ledsCircleArray[2],ledsCircleArray[3],ledsCircleArray[4],ledsCircleArray[5],ledsCircleArray[6],ledsCircleArray[7])
	
##################################################

#fast timer (~5ms)
onevent timer0

	#the following is always executed
	when state == OFF do
		callsub stop
	end
	
	when state == ALIGNFRONT do
		callsub stop
		callsub setProxFront
	end
	
	when state == WAIT do
		callsub stop		
		counterTicks = 0
	end
	
	##########
	


	#the following is only executed when calibrating
	if calibrating == TRUE then
		when state == ROTATE do
			counterTicks = 0
		
			if counterCalibration % 2 == 1 then
				callsub rotateCW
			else
				callsub rotateCCW	
			end
			counterCalibration++
		end
		
		when state == ALIGNFORSTART do
			for i in 0:CALIBRATIONMAXINDEX do
				#don't take two first entries, so robot is properly aligned
				if i > 1 then
					if i % 2 == 0 then
						counterMaxRotateCCW += calibrationArray[i]
					else
						counterMaxRotateCW += calibrationArray[i]
					end
				end
			end
			#calculate average
			counterMaxRotateCCW = counterMaxRotateCCW / ((CALIBRATIONMAXINDEX - 1)/2)
			counterMaxRotateCW = counterMaxRotateCW / ((CALIBRATIONMAXINDEX - 1)/2)
			counterTicks = 0
			callsub rotateCW
		end
		
		#greater than CALIBRATIONMAXINDEX + 1, so robot can get back to initial position
		#note that CALIBRATIONMAXINDEX should be odd
		when counterCalibration > CALIBRATIONMAXINDEX + 1 do
			counterCalibration = 0
			state = WAIT
			nextState = ALIGNFORSTART
		end
		
		
		##########
		
		if state == ALIGNFRONT then
			callsub align
			
			#if front is aligned
			if motor.left.target == 0 and motor.right.target == 0 then
				counterTicks = 0
				state = WAIT
				nextState = ROTATE
			end
		end
		
		if state == ROTATE then
			counterTicks++
			#this ensures that robot rotates at least 45° before trying to align again
			if counterTicks > COUNTERMINROTATE then
				#if rotating CCW
				if motor.left.target &lt; motor.right.target then
					if prox.horizontal[3] > prox.horizontal[1] then
						calibrationArray[counterCalibration - 1] = counterTicks
						counterTicks = 0
						state = WAIT
						nextState = ALIGNFRONT
					end
				#if rotating CW
				elseif motor.left.target > motor.right.target then
					if prox.horizontal[1] > prox.horizontal[3] then
						calibrationArray[counterCalibration - 1] = counterTicks
						counterTicks = 0
						state = WAIT
						nextState = ALIGNFRONT
					end
				end
			end
			
			
		end
		
		if state == ALIGNFORSTART then
			counterTicks++
			if counterTicks > counterMaxRotateCW then
				#reset counter for WAIT functions
				counterTicks = 0
				callsub stop
				#calibrating is finished
#------------>		#calibrating = FALSE
				state = WAIT
				nextState = ALIGNREAR
			end
		end
	#the following is only executed when NOT calibrating
	else
		
		when state == GOFORWARD do
			callsub goForward
			counterTicks = 0
			if counterTakeTemp == COUNTERMAXTAKETEMP and counterTrip == COUNTERMAXTAKETEMP then
				state = OFF
			end
		end
		
		when state == ROTATE do
			#manages direction of rotation
			if counterTrip % 2 == 1 then
				callsub rotateCW
				counterMaxRotate = counterMaxRotateCW
			else
				callsub rotateCCW
				counterMaxRotate = counterMaxRotateCCW
			end
			
			counterTicks = 0
			counterRotate++
		end
		
		when state == TAKETEMP do
		
			callsub stop
			counterTakeTemp++
			counterTicks = 0
		end
		
		##########
	

		
		if state == ROTATE then
			counterTicks++
			when counterTicks >= counterMaxRotate do
				counterTicks = 0
				state = WAIT
				#if first time or if robot has back to wall
				if counterTrip == 0 or counterRotate == 2 then
					nextState = ALIGNREAR
				else
					nextState = GOFORWARD
				end
				#*
				if counterRotate == 1 then
					nextState = GOFORWARD
				else #if counterRotate == 2 then
					nextState = ALIGNREAR
				end
				*#
			end
		end
		
		if state == ALIGNFRONT then
			callsub align
			
			#if front is aligned
			if motor.left.target == 0 and motor.right.target == 0 then
				state = WAIT
				nextState = ROTATE
			end
		end
	
		if state == TAKETEMP then
			counterTicks++
			if counterTicks >= (TIMETAKETEMP / TIMERFAST) then
				temp = temperature
				state = GOFORWARD
			end
		end
	
		if state == GOFORWARD then
			counterTicks++
	
			if counterTicks >= COUNTERMAXGOFORWARD then
				if counterTakeTemp &lt; COUNTERMAXTAKETEMP then
					state = TAKETEMP
				end
				if counterRotate == 1 then
					state = WAIT
					nextState = ROTATE
				end
			end
			
			when prox.horizontal[2] > PROXFRONT do
				state = ALIGNFRONT
			end
		end
	end#if calibrating
	
	
	
	##########
	#the following is always executed
	
	when state == ALIGNREAR do
		callsub setProxRear
		counterTakeTemp = 0
		counterRotate = 0
		counterTrip++
	end
	
	when state == GOTOEND do
		callsub goForward
		counterTicks = 0
	end
	
	when state == TURNAROUND do
		callsub rotateCW
		counterTicks = 0
	end
	
	##########
	
	#the following "if state == ALIGNREAR" must be placed before "if state == WAIT", or else "setProxRear" won't be called before "align"
	if state == ALIGNREAR then
		callsub align
		
		#if rear is aligned
		if motor.left.target == 0 and motor.right.target == 0 then
			#counterTicks has to be reset here, because "if state == ALIGNREAR" is before "if state == WAIT"
			counterTicks = 0
			state = WAIT
			nextState = GOFORWARD
		end
	end
	
	if state == GOTOEND then
		counterTicks++
		when prox.horizontal[2] > PROXFRONT do
			callsub stop
			#set distance between each temp measure
			counterMaxGoForward = counterTicks / (TEMPMAXINDEX + 2)
			counterTicks = 0
			state = WAIT
			nextState = TURNAROUND
		end
	end
	
	if state == TURNAROUND then
		counterTicks++
		#make 180° turn
		when counterTicks > 2 * counterMaxRotateCW do
			callsub stop
			counterTicks = 0
			state = WAIT
			nextState = ALIGNREAR
		end
	end
	
	if state == WAIT then
			
		counterTicks++
		
		if counterTicks >= (TIMEWAIT / TIMERFAST) then
			state = nextState
		end
	end
	
	##########
	
</node>


</network>
